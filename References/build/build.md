# プログラムの仕組み

プログラムは本当はいくつかの工程によりソフトウェアが出来上がります．

1. プリプロセス：ソースコードを補完する．
   - 開発言語そのまま：読める！
2. コンパイル：ソースコードを機械語に直す．
   - アセンブリコード：機械語（アセンブリ言語）で書かれている：読める！
3. アセンブル：機械語をバイトコードに直す．
   - バイトコード：読めない！
4. リンク：バイトコードを実行ファイルに組む．
   - 実行ファイル：読めない！

私たちが直接書いたソースコードは，完全なモノではありません．他人が作った関数や，開発言語自体が元々用意している関数を前提として使って書いています．

プリプロセスは，これらの前提をソースコードに埋め込みます．

コンパイルによって出来上がるアセンブリコードは，アセンブリ言語という単純な命令のみで構成される言語で書かれています．つまり同じアルゴリズムであればC言語でもPython言語でもJavaでも同じアセンブリコードになります．

バイトコードは，アセンブリ言語をバイト表現したものですが，いわゆる0と1だけで書かれたものなので，読んで意味のわかるものではありません．

実行ファイルは，ファイルごとのバイトコードを組み合わせて統合したものです．読めませんが，実行できます．いわゆるソフトウェアのことです．

## インタープリタ　interpreter

「コンパイル」と私たちが呼んでいるものは，上の全ての工程を一度に行うことだったりします．ビルドと言ったりもします．
通常，各工程で出来上がるコード（ファイル）は隠されていたり，ファイル化されずにそのまま次の工程に渡されたりしていて，ソースコードをコンパイルすると実行ファイルが別に出来上がるだけに見えたりします．

「インタープリタ」は，実行ファイルさえも作らない方式です．つまりコンパイルコマンドが実行まで行う方式です．

## pythonソースコードから実行ファイルを作る

pythonソースコードから実行ファイルを作ることができます．他人にソフトウェアを渡すときは，これを渡します．

```
% pyinstaller func.py
```

windowsならfunc.exeが出来上がります．linuxならfuncが出来上がります．

## pythonソースコードからバイトコードにしてみる

pythonソースコードを「バイトコード」にするコンパイル引数があります．つまり中間のアセンブリコードをファイルにせずにバイトコードを出力します．

```
% python -m compileall func.py
```

これを行うと同じフォルダに `func.pyc` というバイトコードができます．
バイトコードはヒトは読めないので，バイトコードを文字列で表示（「dump;ダンプ」）するソフトウェアで読みます

```py
a = 1 + 2
print(a)
```

```
% python -m py_compile myfunc.py
% xxd -bits .\__pycache__\myfunc.cpython-38.pyc      
00000000: 01010101 00001101 00001101 00001010 00000000 00000000  U.....
00000006: 00000000 00000000 10101100 01010000 01101000 01100000  ...Ph`
0000000c: 00010101 00000000 00000000 00000000 11100011 00000000  ......
00000012: 00000000 00000000 00000000 00000000 00000000 00000000  ......
00000018: 00000000 00000000 00000000 00000000 00000000 00000000  ......
0000001e: 00000000 00000000 00000000 00000010 00000000 00000000  ......
00000024: 00000000 01000000 00000000 00000000 00000000 01110011  .@...s
0000002a: 00010000 00000000 00000000 00000000 01100100 00000000  ....d.
00000030: 01011010 00000000 01100101 00000001 01100101 00000000  Z.e.e.
00000036: 10000011 00000001 00000001 00000000 01100100 00000001  ....d.
0000003c: 01010011 00000000 00101001 00000010 11101001 00000011  S.)...
00000042: 00000000 00000000 00000000 01001110 00101001 00000010  ...N).
00000048: 11011010 00000001 01100001 11011010 00000101 01110000  ..a..p
0000004e: 01110010 01101001 01101110 01110100 10101001 00000000  rint..
00000054: 01110010 00000100 00000000 00000000 00000000 01110010  r....r
0000005a: 00000100 00000000 00000000 00000000 11111010 00001001  ......
00000060: 01101101 01111001 01100110 01110101 01101110 01100011  myfunc
00000066: 00101110 01110000 01111001 11011010 00001000 00111100  .py..<
0000006c: 01101101 01101111 01100100 01110101 01101100 01100101  module
00000072: 00111110 00000001 00000000 00000000 00000000 01110011  >....s
00000078: 00000010 00000000 00000000 00000000 00000100 00000001  ......
```

`print`だとか`myfunc.py`とか`module`とか読める部分もありますが，他は意味不明ですね．

## pythonソースコードからアセンブリコードにしてみる．

バイトコードや実行ファイルをアセンブリコードやソースコードに戻すことを「逆アセンブル」と言います．「リバースエンジニアリング」と言ってもいいかもしれません．

pythonの場合，インタプリタなので通常は実行まで行ってしまいます．それを「逆アセンブル」してアセンブリコードを出力します．

本来はソースコードを「アセンブル」だけするのですが，実行をさかのぼる意味で「逆アセンブル」でも同じです．

```
% python -m dis myfunc.py
  1           0 LOAD_CONST               0 (3)
              2 STORE_NAME               0 (a)

  2           4 LOAD_NAME                1 (print)
              6 LOAD_NAME                0 (a)
              8 CALL_FUNCTION            1
             10 POP_TOP
             12 LOAD_CONST               1 (None)
             14 RETURN_VALUE
```

このアセンブリ言語の読み方については，ISコースでは別の授業で習うでしょう．でも，開発言語よりは行数が多いですが，慣れると処理の内容が読めます．



